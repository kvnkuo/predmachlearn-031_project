<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Appendix</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<pre><code>## Loading required package: lattice
## Loading required package: ggplot2
</code></pre>

<p>The primary goal of this report is to find a appropriate model to correctly predict the outcomes of the Weight Lifting Exercise dataset. The WLE dataset comes from Velloso, E. et al. [<strong>R. 1</strong>].</p>

<p>We start by reading the data into R and perform some basic explorarations.</p>

<pre><code class="r">pmldata &lt;- read.csv(&quot;pml-training.csv&quot;,
                      dec=&quot;.&quot;, stringsAsFactors = FALSE, 
                      allowEscapes = TRUE, sep=&quot;,&quot;, 
                      quote = &quot;\&quot;&quot;, header=TRUE, fill = TRUE)
</code></pre>

<p>The dimension of the whole dataset</p>

<pre><code class="r">dim(pmldata)
</code></pre>

<pre><code>## [1] 19622   160
</code></pre>

<p>The prediction is to output classification results. So, we must make sure the classe column is of factor type.</p>

<pre><code class="r">pmldata$classe &lt;- factor(pmldata$classe)
</code></pre>

<p>Before doing the simulation, we import the parallel processing library to speed up the processing.</p>

<pre><code class="r">library(doParallel)
registerDoParallel(cores=4)
</code></pre>

<p>The whole data will be divided into two groups: traing(80%) and testing(20%).</p>

<pre><code class="r">library(caret)
inTrain &lt;- createDataPartition(y=pmldata$classe, p=0.8, list=FALSE)
training &lt;- pmldata[inTrain,]
testing &lt;- pmldata[-inTrain,]
</code></pre>

<pre><code class="r">dim(training)
</code></pre>

<pre><code>## [1] 15699   160
</code></pre>

<p>Both selection of model and method for feature extraction are also inspired by the paper [<strong>R. 1</strong>]. We use Random Forest method to build our model. The original method for feature extraction is based on the followings rules:<br/>
1. In the belt, were selected the mean and variance of the roll, maximum, range and variance of the accelerometer vector, variance of the gyro and variance of the magnetometer.<br/>
2. the  arm,  the  variance  of  the  accelerometer  vector  and  the maximum and minimum of the magnetometer were selected.<br/>
3. In the dumbbell, the selected features were the maximum of the  acceleration,  variance  of  the  gyro  and  maximum  and minimum of the magnetometer, while in the glove, the sum of  the  pitch  and  the  maximum  and  minimum  of  the  gyro were selected.  </p>

<p>Instead of using max, min, sum, mean, var and range of the measured data to build the model, we try an alternative method. For max, min, sum and range values, we simply use the measured data as equivalent ones. For var values, we use the square of the measured data as equivalent ones. For example, in the belt, we use roll_belt instead of mean(roll_belt) in specific time window. Also, in the belt, we use roll_belt<sup>2</sup> instead of var(roll_belt) in specific time window. Our simplified assumption is based on the idea that var is linear equivalent to square.  </p>

<p>Following is the model call(to save processing time, we load the saved one.)</p>

<pre><code class="r">modFit_rf$call
</code></pre>

<pre><code>## train.formula(form = classe ~ roll_belt + roll_belt^2 + total_accel_belt + 
##     accel_belt_x^2 + accel_belt_y^2 + accel_belt_z^2 + gyros_belt_x^2 + 
##     gyros_belt_y^2 + gyros_belt_z^2 + magnet_belt_x^2 + magnet_belt_y^2 + 
##     magnet_belt_z^2 + accel_arm_x^2 + accel_arm_y^2 + accel_arm_z^2 + 
##     magnet_arm_x + magnet_arm_y + magnet_arm_z + total_accel_dumbbell + 
##     gyros_dumbbell_x^2 + gyros_dumbbell_y^2 + gyros_dumbbell_z^2 + 
##     magnet_dumbbell_x + magnet_dumbbell_y + magnet_dumbbell_z + 
##     pitch_forearm + gyros_forearm_x + gyros_forearm_y + gyros_forearm_z, 
##     data = training, method = &quot;rf&quot;, prox = FALSE)
</code></pre>

<p>The confusion matrix of trained model is listed below. The error rates are not bad.</p>

<pre><code class="r">modFit_rf$finalModel$confusion
</code></pre>

<pre><code>##      A    B    C    D    E class.error
## A 4444    5    5    9    1 0.004480287
## B   23 2969   42    4    0 0.022712311
## C    3   23 2699   13    0 0.014243974
## D    7    5   59 2500    2 0.028371551
## E    0    2    5    5 2874 0.004158004
</code></pre>

<p>We investigate the mode with testing data</p>

<pre><code class="r">pred_rf &lt;- predict(modFit_rf, testing)
</code></pre>

<p>and check it with confusion matrix.</p>

<pre><code class="r"># Confusion matrix
confusionMatrix(pred_rf, testing$classe)
</code></pre>

<pre><code>## Confusion Matrix and Statistics
## 
##           Reference
## Prediction    A    B    C    D    E
##          A 1110    9    0    1    0
##          B    5  743    6    0    0
##          C    0    7  676   13    2
##          D    1    0    2  629    1
##          E    0    0    0    0  718
## 
## Overall Statistics
##                                           
##                Accuracy : 0.988           
##                  95% CI : (0.9841, 0.9912)
##     No Information Rate : 0.2845          
##     P-Value [Acc &gt; NIR] : &lt; 2.2e-16       
##                                           
##                   Kappa : 0.9848          
##  Mcnemar&#39;s Test P-Value : NA              
## 
## Statistics by Class:
## 
##                      Class: A Class: B Class: C Class: D Class: E
## Sensitivity            0.9946   0.9789   0.9883   0.9782   0.9958
## Specificity            0.9964   0.9965   0.9932   0.9988   1.0000
## Pos Pred Value         0.9911   0.9854   0.9685   0.9937   1.0000
## Neg Pred Value         0.9979   0.9950   0.9975   0.9957   0.9991
## Prevalence             0.2845   0.1935   0.1744   0.1639   0.1838
## Detection Rate         0.2829   0.1894   0.1723   0.1603   0.1830
## Detection Prevalence   0.2855   0.1922   0.1779   0.1614   0.1830
## Balanced Accuracy      0.9955   0.9877   0.9908   0.9885   0.9979
</code></pre>

<p>The error rates approximately match with error rates in the traing data. The accuracy is 98.8% and its 95% C.I. is (0.9841, 0.9912). Also, the Sensitivity and Specificity for each outcome class are both high. We can conclude that the model&#39;s performance is acceptable. Let&#39;s proceed to the final step, to predict the test data.</p>

<p>Now, we load the test data </p>

<pre><code class="r">pmldata_test &lt;- read.csv(&quot;pml-testing.csv&quot;,
                    dec=&quot;.&quot;, stringsAsFactors = FALSE, 
                    allowEscapes = TRUE, sep=&quot;,&quot;, 
                    quote = &quot;\&quot;&quot;, header=TRUE, fill = TRUE)
</code></pre>

<p>and perform the prediction.</p>

<pre><code class="r">pred_rf_test &lt;- predict(modFit_rf, pmldata_test)
</code></pre>

<pre><code>## Loading required package: randomForest
## randomForest 4.6-10
## Type rfNews() to see new features/changes/bug fixes.
</code></pre>

<pre><code class="r">pred_rf_test
</code></pre>

<pre><code>##  [1] B A B A A E D B A A B C B A E E A B B B
## Levels: A B C D E
</code></pre>

<p>Note: We also use Conditional Inference Trees method to build our model <strong>a. 2</strong>, <strong>a. 3</strong>. The predicted outcomes are no as good as the aboves. However, its predicted test results are the same as our Random Forest based model.           </p>

<h3>Appendix</h3>

<p><strong>a. 1</strong> The main prediction model (Random Forest)</p>

<pre><code class="r">modFit_rf &lt;- train(
    classe ~ roll_belt +
        roll_belt ^ 2 +
        total_accel_belt +
        accel_belt_x ^ 2 +
        accel_belt_y ^ 2 +
        accel_belt_z ^ 2 +
        gyros_belt_x ^ 2 +
        gyros_belt_y ^ 2 +
        gyros_belt_z ^ 2 +
        magnet_belt_x ^ 2 +
        magnet_belt_y ^ 2 +
        magnet_belt_z ^ 2 +
        accel_arm_x ^ 2 +
        accel_arm_y ^ 2 +
        accel_arm_z ^ 2 +
        magnet_arm_x +
        magnet_arm_y +
        magnet_arm_z +
        total_accel_dumbbell +
        gyros_dumbbell_x ^ 2 +
        gyros_dumbbell_y ^ 2 +
        gyros_dumbbell_z ^ 2 +
        magnet_dumbbell_x +
        magnet_dumbbell_y +
        magnet_dumbbell_z +
        pitch_forearm +
        gyros_forearm_x +
        gyros_forearm_y +
        gyros_forearm_z
    , data = training, method = &quot;rf&quot;, prox = FALSE
)
</code></pre>

<p><strong>a. 2</strong> Another prediction model (Conditional Inference Trees)</p>

<pre><code class="r">modFit_ctree$call
</code></pre>

<pre><code>## train.formula(form = classe ~ roll_belt + roll_belt^2 + total_accel_belt + 
##     accel_belt_x^2 + accel_belt_y^2 + accel_belt_z^2 + gyros_belt_x^2 + 
##     gyros_belt_y^2 + gyros_belt_z^2 + magnet_belt_x^2 + magnet_belt_y^2 + 
##     magnet_belt_z^2 + accel_arm_x^2 + accel_arm_y^2 + accel_arm_z^2 + 
##     magnet_arm_x + magnet_arm_y + magnet_arm_z + total_accel_dumbbell + 
##     gyros_dumbbell_x^2 + gyros_dumbbell_y^2 + gyros_dumbbell_z^2 + 
##     magnet_dumbbell_x + magnet_dumbbell_y + magnet_dumbbell_z + 
##     pitch_forearm + gyros_forearm_x + gyros_forearm_y + gyros_forearm_z, 
##     data = training, method = &quot;ctree&quot;)
</code></pre>

<pre><code class="r">pred_ctree &lt;- predict(modFit_ctree, testing)
</code></pre>

<pre><code class="r"># cross validation 
confusionMatrix(pred_ctree, testing$classe)
</code></pre>

<pre><code>## Confusion Matrix and Statistics
## 
##           Reference
## Prediction    A    B    C    D    E
##          A 1052   41   12   17    8
##          B   28  642   28   23   14
##          C    9   40  602   46    9
##          D   19   23   23  542   13
##          E    8   13   19   15  677
## 
## Overall Statistics
##                                          
##                Accuracy : 0.896          
##                  95% CI : (0.886, 0.9054)
##     No Information Rate : 0.2845         
##     P-Value [Acc &gt; NIR] : &lt; 2e-16        
##                                          
##                   Kappa : 0.8684         
##  Mcnemar&#39;s Test P-Value : 0.08557        
## 
## Statistics by Class:
## 
##                      Class: A Class: B Class: C Class: D Class: E
## Sensitivity            0.9427   0.8458   0.8801   0.8429   0.9390
## Specificity            0.9722   0.9706   0.9679   0.9762   0.9828
## Pos Pred Value         0.9310   0.8735   0.8527   0.8742   0.9249
## Neg Pred Value         0.9771   0.9633   0.9745   0.9694   0.9862
## Prevalence             0.2845   0.1935   0.1744   0.1639   0.1838
## Detection Rate         0.2682   0.1637   0.1535   0.1382   0.1726
## Detection Prevalence   0.2880   0.1874   0.1800   0.1580   0.1866
## Balanced Accuracy      0.9574   0.9082   0.9240   0.9096   0.9609
</code></pre>

<p><strong>a. 3</strong> Apply previous ctree model to test data (20 test cases)</p>

<pre><code class="r">pred_ctree_test &lt;- predict(modFit_ctree, pmldata_test)
</code></pre>

<pre><code>## Loading required package: party
## Loading required package: grid
## Loading required package: mvtnorm
## Loading required package: modeltools
## Loading required package: stats4
## Loading required package: strucchange
## Loading required package: zoo
## 
## Attaching package: &#39;zoo&#39;
## 
## The following objects are masked from &#39;package:base&#39;:
## 
##     as.Date, as.Date.numeric
## 
## Loading required package: sandwich
</code></pre>

<pre><code class="r">pred_ctree_test
</code></pre>

<pre><code>##  [1] B A B A A E D B A A B C B A E E A B B B
## Levels: A B C D E
</code></pre>

<h3>Reference</h3>

<p><strong>R. 1</strong>
Velloso, E.; Bulling, A.; Gellersen, H.; Ugulino, W.; Fuks, H. Qualitative Activity Recognition of Weight Lifting Exercises. Proceedings of 4th International Conference in Cooperation with SIGCHI (Augmented Human &#39;13) . Stuttgart, Germany: ACM SIGCHI, 2013.
Read more: <a href="http://groupware.les.inf.puc-rio.br/har#wle_paper_section#ixzz3jKxnqNYs">http://groupware.les.inf.puc-rio.br/har#wle_paper_section#ixzz3jKxnqNYs</a></p>

</body>

</html>
